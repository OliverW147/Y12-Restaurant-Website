![website](https://github.com/OliverW147/Y12-Restaurant-Website/blob/main/image.png?raw=true)

Script for presentations:

1.

Efficient automation is crucial for organisational success. Cost-effective and dependable software programs are revolutionising inventory management systems and leading to significant improvements in efficiency. This presentation details the design and development of a Python-based solution for restaurant inventory and booking management.
The solution aims to:
•	Automate inventory tracking, to eliminate manual processes and minimise errors.
•	Integrate online bookings with pre-ordering functionalities.
•	Allow customer and staff logins through an account system.
•	Generate low-stock alerts for staff.
•	And provide statistics on inventory usage.
To achieve these goals, the system's functionality is divided into frontend and backend components. This presentation focuses on the backend.
A flowchart depicts the high-level interactions between components of the system. The blue nodes represent frontend scripts for parsing inputs, and the green nodes represent the backend methods for handling processes, calculations, and data manipulation. The process is initialised by either: a customer booking, or staff requesting statistics and updating inventory. A client-side script validates and forwards user input to the backend to complete the appropriate action.
To translate the high-level functionalities outlined in the flowchart into a functional program, the backend is divided into five modular classes: Bookings, Inventory, Meals, Usages, and Accounts. As seen in the comments on screen, each class encapsulates specific functionalities to achieve the outlined goals.
These outlines are utilised to implement the functionality of each class.
The Bookings class is the first of these classes, and contains four methods to manage booking requests and table availability.
Its constructor method creates an empty dictionary self.bookings to store booking information and sets the total number of tables in the restaurant (self.tables) to a value of 25.
The create_booking method receives the customer’s name, table, time, meals, and also Inventory, Meals, and Usages objects. It then creates a booking ID using the customer's name and booking time and then interacts with the Meals class to verify if the requested table is free and that sufficient ingredients are in stock to prepare the requested meals.
If these checks pass, the method appends the bookings to self.bookings and removes ingredients to be used in the requested meals from the stock.
Cancel_booking deletes a booking given that booking’s ID, and get_available_tables returns a list of all tables available at the given time.
The second class is the Inventory class, which manages stock levels of ingredients.
Its constructor creates an empty dictionary, self.items, to store the inventory information. Each key in the dictionary represents an ingredient name, and the corresponding value represents the quantity of that ingredient in stock.
The add and remove ingredient methods manipulate a specified quantity of an ingredient in the stock dictionary, and the get_stock and get_quantity methods return quantities of ingredients within the stock.
The meals class contains four methods. Two to manage recipes, and two to check if a given combination of meals can be prepared considering current stock levels.
These are the first three methods in detail.
The fourth method, is_available_with_quantities, is more complicated, and works by looping through requested meals, checking if recipes exist, accumulating the ingredients needed for the meals, and then checking if the inventory contains all the necessary ingredients.
The next class, Usages, contains three methods to track ingredient usage.
The usage class’s constructor defines the log dictionary. The three methods contained in the usages class all track ingredient usage in some way. The log_usage method is called to record all ingredients used in a confirmed booking. Get_usages allows staff to view usage history of a given item, with optional time and ingredient filters.
The predict_shortages method iterates through each ingredient with a logged usage and returns a list of ingredients that have exhausted 70% of their stock within the past week.
The last class, Accounts, manages customer account creation and authentication, and also allows for verification of staff.
Its constructor method defines the default staff credentials and loads customer accounts from a file through its load_accounts method. The save_accounts method is similar in that it writes the dictionary in memory back to the file.
The login and staff_login methods determine whether a specified username and password are within the accounts dictionary, and the register method checks if the username already exists, and then writes the given username and password to the accounts dictionary.
●	A simple text I/O interface was constructed for the purpose of debugging and demonstrating these classes.
●	*cut to video* 
●	In this demonstration, all objects are initialised here. The add_ingredient method is called to add flour, eggs, and milk to the stock. A recipe for pancakes is also appended to a dictionary within the meals object.
●	A sample booking for John Doe who wants two pancakes will be created. This booking is successful. If a booking for Jane Doe, who also wants pancakes is created, the booking is unsuccessful. This is intended, as there is only enough flour in the stock for two pancakes. Similar results can be observed when an attempt is made to book an already-reserved table.
●	After logging out, there is an option to login again as a staff member. Staff can view bookings, manage the inventory, view usage logs of ingredients, and call the predict shortages method.
The restaurant booking and inventory management system's backend is capable of effectively achieving the defined goals when paired with a well-designed frontend, such as this UI by OpenTable (on video). While the current demonstration script requires manual data entry and lacks input validation, a proper web-based UI addresses these limitations. The following presentation will focus on the frontend's functionalities, including user-friendly selection controls for bookings, consistent data handling for ingredients, and password hashing to protect customer information. 
Notably, the backend could utilise an external database to ensure bookings, inventory levels, and usage logs are persistent, along with the accounts dictionary.
Overall, the modular design of this backend solution supports scalability and customisation. By integrating a user-friendly frontend with persistent data storage, this solution has the potential to improve the efficiency of restaurant inventory and booking systems.
Thank you for listening.

2.

The previous presentation detailed the development of a Python-based system for restaurant inventory and booking management. This presentation explores the iterative development of a restaurant’s web application, leveraging the preceding Python-based system to manage the web-app’s core functionality.
In order to effectively streamline customer interactions, the web-app must be user-friendly, visually appealing, and responsive.
Additionally, it must include booking, authentication, and inventory and order administration components.
A flowchart is utilized to structure the logic of the website. This flowchart outlines the process for handling inputs and outputs involved in navigating the web application. These processes include accepting login credentials and managing booking requests to redirect users between pages.
Additionally, scaffolding is employed to guide the markup of the website.
An alternating grid layout is selected for displaying the main content on the homepage. This layout, commonly found in similar applications, is visually appealing to a broad audience.
For user authentication, a standard login and registration form with two text boxes is utilized. To facilitate customer bookings, a form incorporating combo boxes, date-time pickers, and number steppers is implemented.
To develop the website, the widely-used Flask web framework is selected due to its compatibility with Python, the language used for the restaurant's inventory and booking management classes. Initially, a website directory is created following the structure depicted in this screenshot. This structure divides the website development into distinct increments. The first increment focuses on implementing basic functionalities such as authentication, booking, and inventory management systems. The second increment addresses bug fixing, and the third increment concentrates on markup and styling.
In the initial iteration, Flask and the backend from the previous presentation are imported into a Python file, app.py. All objects are initialized, and routes are created using HTML templates, enabling users to register an account and log in. Once logged in, users can book a table by providing their name, preferred table number, booking time, and by selecting meals. The booking process verifies table availability and ensures sufficient ingredients are in the inventory for the selected meals. Staff members have a separate login to access additional features. They can manage the restaurant's inventory by adding ingredients and viewing current stock levels, as well as viewing logs of ingredient usage over time. The staff dashboard provides links for easy access to these features.
In this initial iteration, the routes and views in Flask manage user interactions, with each route corresponding to a specific page or functionality. For instance, the login route handles rendering the login form (GET requests) and processing form data for authentication (POST requests). The /book route is responsible for handling table bookings, ensuring the user is logged in, and processing the booking form data.
HTML templates structure the pages and incorporate Flask-specific syntax for dynamic content rendering. For example, the ingredients interface dynamically generates a list based on the ingredients object. Flash messages provide user feedback, indicating outcomes such as successful or failed bookings. Backend objects, including Bookings, Inventory, Meals, Usages, and Accounts, are initialized with sample data and invoked throughout the routes to handle POST requests. The POST method in the inventory route, for instance, uses input from a form to add an ingredient to the inventory.
Additionally, Flask's sessions module is employed to manage authentication and increase security through signed cookies. In subsequent iterations, this module is also used to transmit session information in booking requests and improve data persistence.
After testing edge cases in the first iteration, including scenarios with blank inputs, several issues were identified for fixing in the second iteration.
One major problem is the absence of restrictions on booking times, allowing users to book tables outside the restaurant's operating hours and in irregular time slots. To address this, the booking page’s HTML file in the second iteration will include a dropdown menu with various hour-long time blocks.
The specific change made in the updated HTML file involves the use of an innovative JavaScript listener. This listener dynamically generates each hour within the restaurant's open and close hours, formats them as strings, and appends them as options to the new dropdown menu. The advantage of using a listener is that it allows for easy customization of the dropdown menu.
Additionally, in the first iteration, there are no methods called for the meals object, making it impossible for staff to update information about the meals. In this iteration, a new route is implemented, allowing staff to manage meals by adding or removing them from the menu. Another JavaScript listener dynamically handles adding new ingredient fields to the form.
Another issue identified is the allowance of any name for the booking, which could result in confusing and duplicate booking names. To resolve this, the booking process has been modified to use customers' session usernames as the booking names.
Additionally, successful actions are now displayed in green instead of red, and features have been added to enable staff to better modify bookings, inventory, and menu items. A function for staff to cancel bookings has also been introduced.
With testing and bug fixing complete, the website is now to be fully styled. In the third and final iteration, the CSS has been updated to feature a light background, updated font, and improved navigation and form styles, including enhanced table designs.
The homepage now aligns with the initial scaffold and contains a Bootstrap jumbotron for a more engaging introduction. It features larger, visually appealing navigation buttons and new sections for "About Us," "Our Menu," and "Contact Us," each with images and call-to-action buttons leading to three new routes.
Numerous additional features have been implemented to ensure the website is highly user-friendly. Buttons on the front page and in the navbar dynamically change depending on whether the user is logged in as a customer or a staff member. All pages now include the navbar and footer, the staff dashboard has been overhauled, placeholder text is more appropriately themed for a restaurant, and feedback messages are now displayed in a more formatted manner.
Overall, the restaurant booking and inventory management web application successfully achieves its goal of being user-friendly and visually appealing. The final application consists of approximately 1,000 lines of Python, HTML, and CSS, and includes functional authentication and booking pages, as well as a dashboard for staff to manage bookings, inventory, and meals.
All project files are accessible via the link on the screen, and this is the bibliography. Thank you for listening.
